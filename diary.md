# 测试文档 
该文档主要记录每次测试出现的情况
////////////////////////////////////////////////////////

现在完成了关于mac_rx_test的移植，接下去要先debug fifoc2cs.v

////////////////////////////////////////////////////////

这个突然就好用了，完全不知道发生了什么。
但是找到一个bug
那就是如果显示某个多位的值，然后发现显示的只和最后一位相关，那么最大的可能性是：
显示或者传递的某一个port，位数出现了问题，这个之后必须要好好检查

////////////////////////////////////////////////////////

难以理解，在fifo_read.v这个文件里面，改变next_state的一行代码，就能改变mac的读时序，但是问题在于我都不没有使用到fifo_read.v
这个实在是太诡异了，后面真的需要多看看发生了什么，现在先继续的debug

////////////////////////////////////////////////////////
看了一下state，发现state居然是在跳动的，然后每次呈现的情况完全不同，不知道出现在什么bug，还是打算上ila了
据说只要debug文件和源文件都没有ila，ila就可以去掉的，不至于毁了一个项目
////////////////////////////////////////////////////////

FUCK!!!
现在的mac_rx完全都是大bug，瞬间能把整个fifo直接充满，现在一定是个bug。
可能得看一下具体的state了

////////////////////////////////////////////////////////

fifo 还是需要需要使用Distributed RAM，我也不知道为什么
然后后面的问题又出现了，当发送多次之后，突然就没法发送了，这个问题现在不debug了
但是后面可以多试试，感觉可以对这个问题好好解决一下了

////////////////////////////////////////////////////////

fifo_tx_write debug done
这个终于结束了，明天开始弄mac_rx了

////////////////////////////////////////////////////////

bug出现在有没有检测fifo是否初始化完成

////////////////////////////////////////////////////////

fifo_read的一点变化可能会导致无法读完整，这个问题后面还是可以再仔细研究一下的，感觉verilog好多地方都是坑啊
现在还是打算使用Block RAM去做这个，我也不知道为什么
但是感觉似乎喂数据都能喂进去，但是让它有规律的吐出来还是挺麻烦的

////////////////////////////////////////////////////////

fifo还是有种类的，还是得使用Distributed Clocks
这样功能少了一点，但是响应能快一点
Built-in FIFO这个还是没有搞定，这个不知道除了什么问题
还是说一下吧：
Block RAM上来说，这个响应慢一些，但是如果使用这的话，还是可以在多次读写之后完成；
Distributed RAM 这个响应快一点，之后还是用这个吧
Built-in FIFO，这个多次读写还有问题，之后还是可能值得研究的

////////////////////////////////////////////////////////

我真是fuck了，fifo连led都连接不在一起了，不知道发生了什么，我觉得还是好好整理一下fifo

////////////////////////////////////////////////////////

搞不定了，之前的可以成功的东西都完不成通讯，这个肯定有问题，先不debug这个了

////////////////////////////////////////////////////////

真是服了，在mac通讯中，rgmii_txc是output的，居然会输出一个时钟，否则会导致无法通信无法连接
还是以前的问题，我都不知道问题在哪里了，我可以先试试之前的那个test

////////////////////////////////////////////////////////

开始mac_rx的调试。

////////////////////////////////////////////////////////

完成fifo与led的联系，这里发现一个问题，必须要先确定fifo一定要先初始化。
必须确保fifo的full是置低的 fifo_test

////////////////////////////////////////////////////////

写完了关于fifo的读写方面的测试工作，感觉之前应该做过相关的工作，今天重新试一下

////////////////////////////////////////////////////////

mac_rx 现在写起来太麻烦了，我可能得写一点文档了，现在的debug先结束。
先开始写一下文档，把每个重要的变量说明一下

////////////////////////////////////////////////////////

测试的很简单，几乎就是把lei重新测试了一下
测试通过

////////////////////////////////////////////////////////

终于解决了，这个问题简直是太神了，主要问题是，状态机位置没有留够，只有两位
这个导致的问题是，能够触发fd的两个状态根本无法到达。

这个问题太诡异了，最后是在查看设计完成的电路图才发现的。
两个本来随着信号调节的信号居然直接接地了。

这个得到的教训是，在没有完全定稿之前，所有的状态机应定义为8位或者16位，这样虽然消耗的资源多，但是不会出现这样的问题。

以上，该模块调试完成

////////////////////////////////////////////////////////

测试一个简单的led应用，简直是bug了。
调了一天都没发现问题，具体情况是：
1. 向上计数完全无法使用，向下计数没有问题
2. x
3. 在fs之后有一段是空窗期，
   1. 如果向下计数data_cnt自动置为4‘hF;
   2. 如果向上计数data_cnt自动置为4‘h1;
   3. 我怀疑是fd没有传出去
   4. 而且这个空窗期所有的灯应该都没有完全亮

这个简直太坑了，一定要记录一下，一会儿再试试

////////////////////////////////////////////////////////

新增模块，一共有32个led灯，可以同时兼听4个字节，方便调试
其xdc文件值得参考
该模块调试成功

////////////////////////////////////////////////////////

修改了key的文件，之前的key会出现连续按键的情况
如果这样的按键出现在串口发送过程中，在按键过程中会疯狂发数据
所以现在更改为必须按一次发送一次

现在串口发送成功，之后测试串口接收，再之后把fifo联系在一起
串口初步发送成功

////////////////////////////////////////////////////////
按键测试成功，按键具有防抖设置，在0.01s必须按键都被按下才被识别是按键一次
产生的flag可以延续1s，或者事件完成置低

////////////////////////////////////////////////////////
串口测试
完全失败，现在能够接收到最后一个字节，通过led显示完全正确
但是无法计数接收的数据长度
计划先测试一个key模块

////////////////////////////////////////////////////////
测试串口
新开一个新的方向，使用串口通信
复制例程，debug成功

////////////////////////////////////////////////////////
测试mac_rx_lite
现在接收数据可以完成，可以看到接收数据的长度
发送数据可以完成，但是会大量发送
01 00 00 01 00 00 01 00 01 00 01 00 （发送12个数据 55 AA 00 01 02 03 04 05 06 07 08 1C）
01 00 00 01 00 01 00 01 00 01 00 00 01 00 （发送14个数据 55 AA 00 01 02 03 04 05 06 07 08 1C 1D 1E）
表示发送数据的最后一位
在reset之后结束发送
////////////////////////////////////////////////////////