# 测试文档 

该文档主要记录每次测试出现的情况
003D///////////////////////////////////////////////////

调节fifo2adc的时序问题，感觉需要改一点点

003C///////////////////////////////////////////////////

平台搭完了，先仿真一下，发现问题很多，开始慢慢改

003B///////////////////////////////////////////////////

按键的东西弄完了，可以继续开始fifo2adc的debug了

003A///////////////////////////////////////////////////

突然有一个想法，感觉可以用ila和按键做一个可以连续测试的平台出来，这样可以节约时间

0039///////////////////////////////////////////////////

intan的check和conf补上了，可以开始调试fifo2adc了

0038///////////////////////////////////////////////////

开始fifo2adc的debug准备，突然想起来，应该把intan的conf和check部分补上

0037///////////////////////////////////////////////////

感觉出了好多七七八八的bug，完全是不用心啊，这些错误犯的简直是太奇葩了
后面开始fifo2adc的debug

0036///////////////////////////////////////////////////

开始调整一下intan部分的debug，刚刚发现state不跳动，感觉可能有点问题，现在重新写一个ila

0035///////////////////////////////////////////////////

开始改intan部分，发现之前fifo2adc犯了之前的错误，所以都整合到cs_numq去了
后面还得大改一下

0034///////////////////////////////////////////////////

mac_tx没问题了，之后开始debug intan2fifod部分

0033///////////////////////////////////////////////////

新增了新的key文件，可以满足连按和多次按键，开始debug mac_tx

0032///////////////////////////////////////////////////

整理完善程序至all

0031///////////////////////////////////////////////////

最后还是用最暴力的方法解决了，早知如此还是应该这么做的，之前的方法实在是太消耗资源了
后面看看是不是都再优化一下，这个东西如果自己写太容易出错了，弄了个程序稍微处理一下
后面测试现在没问题了，最起码现在多次赋值没任何问题了

0030///////////////////////////////////////////////////

发现时钟有问题，原因是cs_num消耗资源太多了，得略微改一下

002F///////////////////////////////////////////////////

cs_clk移植成功

002E///////////////////////////////////////////////////

时序是有点问题，但是问题确实不大，之前的一句话写错了，而且即使改过来也没什么用
主要的问题是：mac中间的flag_udp_rxdv这个真是太bug了，只要是第一次发送成功，就会一直置高
只有在再发送的时候会短暂的降低，所以以这个判断udp_rx发送会出大问题，就是我发现的，显示一直发送
现在终于解决了，开始加入cs文件

002D///////////////////////////////////////////////////

还是时序问题，我估计得找人处理一下了，我这边弄了半天没弄出来。
另外开始调试intan部分了

002C///////////////////////////////////////////////////

还是有bug，现在还是只能弄一次，这个不太对

002B///////////////////////////////////////////////////

fifoc2cs 全部测试完成了，这个教训太惨重了，之后一定要注意相关问题

002A///////////////////////////////////////////////////

fifoc2cs终于debug了，之后记住了，if写完之后，一定把else写上，这是很严肃的纪律问题

0029///////////////////////////////////////////////////

简直bug了，打算重来一次，一点一点加入东西

0028///////////////////////////////////////////////////

bug很奇特，如果没有任何监管可以跑完一次，但是如果上监管，整个程序都是乱来的，不知道发生了什么

0027///////////////////////////////////////////////////

把第一部分的state转进去了，差不多了，但是还出了点问题，只能接一次数据

0026///////////////////////////////////////////////////

想到一种机制，可以把两个文件的状态机结合在一起，现在看来还能成功一点

0025///////////////////////////////////////////////////

还是有问题，还是先从mac_rx_test的那个可以使用的test.v开始重新修改到cs的时序

0024///////////////////////////////////////////////////

开始第一步，先把fifo_full确定没问题了
后面一步让cs控制mac读取数据至fifoc

0023///////////////////////////////////////////////////

还是先调试test_cs的第一步
还是先从fifo_full开始弄起来吧

0022///////////////////////////////////////////////////

电压什么的没什么问题，但是现在时钟还有问题，感觉差分时钟还是不太对，
后面再一下吧

0021///////////////////////////////////////////////////

开始debug cs了，感觉问题非常大，或者cs_cmd得重新写吧
先调试一下新的板子

0020///////////////////////////////////////////////////

做了一点准备，把之前确保没问题的文件收录一下
后面开始debug cs_cmd
顺便把fifo_full的检测加上了，检测语言和state更新都重新做过了

001F////////////////////////////////////////////////////

开始debug cs
首先需要补上之前没有考虑到的fifo的初始化问题，现在需要检查一下fifo_full了

001E////////////////////////////////////////////////////

还是学到了一点新东西的，总的来说，在使用fifo的时候，一定要先确定fifo已经初始化了
然后第二个问题是，只有UltraScale的芯片才能使用Bulit-in Fifo，所以现在不能用挺正常的

001D////////////////////////////////////////////////////

还是想试一下Distributed Fifo，先试一下吧

001C////////////////////////////////////////////////////

cs_num完全没问题了，之后测试cs_cmd了

001B////////////////////////////////////////////////////

fifoc2cs.v测试完成，终于可以debug cs部分了。

001A////////////////////////////////////////////////////

现在完成了关于mac_rx_test的移植，接下去要先debug fifoc2cs.v

0019////////////////////////////////////////////////////

这个突然就好用了，完全不知道发生了什么。
但是找到一个bug
那就是如果显示某个多位的值，然后发现显示的只和最后一位相关，那么最大的可能性是：
显示或者传递的某一个port，位数出现了问题，这个之后必须要好好检查

0018////////////////////////////////////////////////////

难以理解，在fifo_read.v这个文件里面，改变next_state的一行代码，就能改变mac的读时序，但是问题在于我都不没有使用到fifo_read.v
这个实在是太诡异了，后面真的需要多看看发生了什么，现在先继续的debug

0017////////////////////////////////////////////////////

看了一下state，发现state居然是在跳动的，然后每次呈现的情况完全不同，不知道出现在什么bug，还是打算上ila了
据说只要debug文件和源文件都没有ila，ila就可以去掉的，不至于毁了一个项目

0016////////////////////////////////////////////////////

FUCK!!!
现在的mac_rx完全都是大bug，瞬间能把整个fifo直接充满，现在一定是个bug。
可能得看一下具体的state了

0015////////////////////////////////////////////////////

fifo 还是需要需要使用Distributed RAM，我也不知道为什么
然后后面的问题又出现了，当发送多次之后，突然就没法发送了，这个问题现在不debug了
但是后面可以多试试，感觉可以对这个问题好好解决一下了

0014////////////////////////////////////////////////////

fifo_tx_write debug done
这个终于结束了，明天开始弄mac_rx了

0013////////////////////////////////////////////////////

bug出现在有没有检测fifo是否初始化完成

0012////////////////////////////////////////////////////

fifo_read的一点变化可能会导致无法读完整，这个问题后面还是可以再仔细研究一下的，感觉verilog好多地方都是坑啊
现在还是打算使用Block RAM去做这个，我也不知道为什么
但是感觉似乎喂数据都能喂进去，但是让它有规律的吐出来还是挺麻烦的

0011////////////////////////////////////////////////////

fifo还是有种类的，还是得使用Distributed Clocks
这样功能少了一点，但是响应能快一点
Built-in FIFO这个还是没有搞定，这个不知道除了什么问题
还是说一下吧：
Block RAM上来说，这个响应慢一些，但是如果使用这的话，还是可以在多次读写之后完成；
Distributed RAM 这个响应快一点，之后还是用这个吧
Built-in FIFO，这个多次读写还有问题，之后还是可能值得研究的

0010////////////////////////////////////////////////////

我真是fuck了，fifo连led都连接不在一起了，不知道发生了什么，我觉得还是好好整理一下fifo

000F////////////////////////////////////////////////////

搞不定了，之前的可以成功的东西都完不成通讯，这个肯定有问题，先不debug这个了

000E////////////////////////////////////////////////////

真是服了，在mac通讯中，rgmii_txc是output的，居然会输出一个时钟，否则会导致无法通信无法连接
还是以前的问题，我都不知道问题在哪里了，我可以先试试之前的那个test

000D////////////////////////////////////////////////////

开始mac_rx的调试。

000C////////////////////////////////////////////////////

完成fifo与led的联系，这里发现一个问题，必须要先确定fifo一定要先初始化。
必须确保fifo的full是置低的 fifo_test

000B////////////////////////////////////////////////////

写完了关于fifo的读写方面的测试工作，感觉之前应该做过相关的工作，今天重新试一下

000A////////////////////////////////////////////////////

mac_rx 现在写起来太麻烦了，我可能得写一点文档了，现在的debug先结束。
先开始写一下文档，把每个重要的变量说明一下

0009////////////////////////////////////////////////////

测试的很简单，几乎就是把lei重新测试了一下
测试通过

0008////////////////////////////////////////////////////

终于解决了，这个问题简直是太神了，主要问题是，状态机位置没有留够，只有两位
这个导致的问题是，能够触发fd的两个状态根本无法到达。

这个问题太诡异了，最后是在查看设计完成的电路图才发现的。
两个本来随着信号调节的信号居然直接接地了。

这个得到的教训是，在没有完全定稿之前，所有的状态机应定义为8位或者16位，这样虽然消耗的资源多，但是不会出现这样的问题。

以上，该模块调试完成

0007////////////////////////////////////////////////////

测试一个简单的led应用，简直是bug了。
调了一天都没发现问题，具体情况是：

1. 向上计数完全无法使用，向下计数没有问题
2. x
3. 在fs之后有一段是空窗期，

   1. 如果向下计数data_cnt自动置为4‘hF;
   2. 如果向上计数data_cnt自动置为4‘h1;
   3. 我怀疑是fd没有传出去
   4. 而且这个空窗期所有的灯应该都没有完全亮

这个简直太坑了，一定要记录一下，一会儿再试试

0006////////////////////////////////////////////////////

新增模块，一共有32个led灯，可以同时兼听4个字节，方便调试
其xdc文件值得参考
该模块调试成功

0005////////////////////////////////////////////////////

修改了key的文件，之前的key会出现连续按键的情况
如果这样的按键出现在串口发送过程中，在按键过程中会疯狂发数据
所以现在更改为必须按一次发送一次

现在串口发送成功，之后测试串口接收，再之后把fifo联系在一起
串口初步发送成功

0004////////////////////////////////////////////////////

按键测试成功，按键具有防抖设置，在0.01s必须按键都被按下才被识别是按键一次
产生的flag可以延续1s，或者事件完成置低

0003////////////////////////////////////////////////////
串口测试
完全失败，现在能够接收到最后一个字节，通过led显示完全正确
但是无法计数接收的数据长度
计划先测试一个key模块

0002////////////////////////////////////////////////////

测试串口
新开一个新的方向，使用串口通信
复制例程，debug成功

0001////////////////////////////////////////////////////

测试mac_rx_lite
现在接收数据可以完成，可以看到接收数据的长度
发送数据可以完成，但是会大量发送
01 00 00 01 00 00 01 00 01 00 01 00 （发送12个数据 55 AA 00 01 02 03 04 05 06 07 08 1C）
01 00 00 01 00 01 00 01 00 01 00 00 01 00 （发送14个数据 55 AA 00 01 02 03 04 05 06 07 08 1C 1D 1E）
表示发送数据的最后一位
在reset之后结束发送

0000////////////////////////////////////////////////////
