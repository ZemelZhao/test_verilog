# 测试文档 
该文档主要记录每次测试出现的情况
///////////////////////////////////////////////////////

发现时钟有问题，原因是cs_num消耗资源太多了，得略微改一下

///////////////////////////////////////////////////////

cs_clk移植成功

///////////////////////////////////////////////////////

时序是有点问题，但是问题确实不大，之前的一句话写错了，而且即使改过来也没什么用
主要的问题是：mac中间的flag_udp_rxdv这个真是太bug了，只要是第一次发送成功，就会一直置高
只有在再发送的时候会短暂的降低，所以以这个判断udp_rx发送会出大问题，就是我发现的，显示一直发送
现在终于解决了，开始加入cs文件

///////////////////////////////////////////////////////

还是时序问题，我估计得找人处理一下了，我这边弄了半天没弄出来。
另外开始调试intan部分了

///////////////////////////////////////////////////////

还是有bug，现在还是只能弄一次，这个不太对

///////////////////////////////////////////////////////

fifoc2cs 全部测试完成了，这个教训太惨重了，之后一定要注意相关问题

///////////////////////////////////////////////////////

fifoc2cs终于debug了，之后记住了，if写完之后，一定把else写上，这是很严肃的纪律问题

///////////////////////////////////////////////////////

简直bug了，打算重来一次，一点一点加入东西

///////////////////////////////////////////////////////

bug很奇特，如果没有任何监管可以跑完一次，但是如果上监管，整个程序都是乱来的，不知道发生了什么

///////////////////////////////////////////////////////

把第一部分的state转进去了，差不多了，但是还出了点问题，只能接一次数据

///////////////////////////////////////////////////////

想到一种机制，可以把两个文件的状态机结合在一起，现在看来还能成功一点

///////////////////////////////////////////////////////

还是有问题，还是先从mac_rx_test的那个可以使用的test.v开始重新修改到cs的时序

///////////////////////////////////////////////////////

开始第一步，先把fifo_full确定没问题了
后面一步让cs控制mac读取数据至fifoc

///////////////////////////////////////////////////////

还是先调试test_cs的第一步
还是先从fifo_full开始弄起来吧

///////////////////////////////////////////////////////

电压什么的没什么问题，但是现在时钟还有问题，感觉差分时钟还是不太对，
后面再一下吧

///////////////////////////////////////////////////////

开始debug cs了，感觉问题非常大，或者cs_cmd得重新写吧
先调试一下新的板子

///////////////////////////////////////////////////////

做了一点准备，把之前确保没问题的文件收录一下
后面开始debug cs_cmd
顺便把fifo_full的检测加上了，检测语言和state更新都重新做过了

////////////////////////////////////////////////////////

开始debug cs
首先需要补上之前没有考虑到的fifo的初始化问题，现在需要检查一下fifo_full了

////////////////////////////////////////////////////////

还是学到了一点新东西的，总的来说，在使用fifo的时候，一定要先确定fifo已经初始化了
然后第二个问题是，只有UltraScale的芯片才能使用Bulit-in Fifo，所以现在不能用挺正常的

////////////////////////////////////////////////////////

还是想试一下Distributed Fifo，先试一下吧

////////////////////////////////////////////////////////

cs_num完全没问题了，之后测试cs_cmd了

////////////////////////////////////////////////////////

fifoc2cs.v测试完成，终于可以debug cs部分了。

////////////////////////////////////////////////////////

现在完成了关于mac_rx_test的移植，接下去要先debug fifoc2cs.v

////////////////////////////////////////////////////////

这个突然就好用了，完全不知道发生了什么。
但是找到一个bug
那就是如果显示某个多位的值，然后发现显示的只和最后一位相关，那么最大的可能性是：
显示或者传递的某一个port，位数出现了问题，这个之后必须要好好检查

////////////////////////////////////////////////////////

难以理解，在fifo_read.v这个文件里面，改变next_state的一行代码，就能改变mac的读时序，但是问题在于我都不没有使用到fifo_read.v
这个实在是太诡异了，后面真的需要多看看发生了什么，现在先继续的debug

////////////////////////////////////////////////////////
看了一下state，发现state居然是在跳动的，然后每次呈现的情况完全不同，不知道出现在什么bug，还是打算上ila了
据说只要debug文件和源文件都没有ila，ila就可以去掉的，不至于毁了一个项目
////////////////////////////////////////////////////////

FUCK!!!
现在的mac_rx完全都是大bug，瞬间能把整个fifo直接充满，现在一定是个bug。
可能得看一下具体的state了

////////////////////////////////////////////////////////

fifo 还是需要需要使用Distributed RAM，我也不知道为什么
然后后面的问题又出现了，当发送多次之后，突然就没法发送了，这个问题现在不debug了
但是后面可以多试试，感觉可以对这个问题好好解决一下了

////////////////////////////////////////////////////////

fifo_tx_write debug done
这个终于结束了，明天开始弄mac_rx了

////////////////////////////////////////////////////////

bug出现在有没有检测fifo是否初始化完成

////////////////////////////////////////////////////////

fifo_read的一点变化可能会导致无法读完整，这个问题后面还是可以再仔细研究一下的，感觉verilog好多地方都是坑啊
现在还是打算使用Block RAM去做这个，我也不知道为什么
但是感觉似乎喂数据都能喂进去，但是让它有规律的吐出来还是挺麻烦的

////////////////////////////////////////////////////////

fifo还是有种类的，还是得使用Distributed Clocks
这样功能少了一点，但是响应能快一点
Built-in FIFO这个还是没有搞定，这个不知道除了什么问题
还是说一下吧：
Block RAM上来说，这个响应慢一些，但是如果使用这的话，还是可以在多次读写之后完成；
Distributed RAM 这个响应快一点，之后还是用这个吧
Built-in FIFO，这个多次读写还有问题，之后还是可能值得研究的

////////////////////////////////////////////////////////

我真是fuck了，fifo连led都连接不在一起了，不知道发生了什么，我觉得还是好好整理一下fifo

////////////////////////////////////////////////////////

搞不定了，之前的可以成功的东西都完不成通讯，这个肯定有问题，先不debug这个了

////////////////////////////////////////////////////////

真是服了，在mac通讯中，rgmii_txc是output的，居然会输出一个时钟，否则会导致无法通信无法连接
还是以前的问题，我都不知道问题在哪里了，我可以先试试之前的那个test

////////////////////////////////////////////////////////

开始mac_rx的调试。

////////////////////////////////////////////////////////

完成fifo与led的联系，这里发现一个问题，必须要先确定fifo一定要先初始化。
必须确保fifo的full是置低的 fifo_test

////////////////////////////////////////////////////////

写完了关于fifo的读写方面的测试工作，感觉之前应该做过相关的工作，今天重新试一下

////////////////////////////////////////////////////////

mac_rx 现在写起来太麻烦了，我可能得写一点文档了，现在的debug先结束。
先开始写一下文档，把每个重要的变量说明一下

////////////////////////////////////////////////////////

测试的很简单，几乎就是把lei重新测试了一下
测试通过

////////////////////////////////////////////////////////

终于解决了，这个问题简直是太神了，主要问题是，状态机位置没有留够，只有两位
这个导致的问题是，能够触发fd的两个状态根本无法到达。

这个问题太诡异了，最后是在查看设计完成的电路图才发现的。
两个本来随着信号调节的信号居然直接接地了。

这个得到的教训是，在没有完全定稿之前，所有的状态机应定义为8位或者16位，这样虽然消耗的资源多，但是不会出现这样的问题。

以上，该模块调试完成

////////////////////////////////////////////////////////

测试一个简单的led应用，简直是bug了。
调了一天都没发现问题，具体情况是：
1. 向上计数完全无法使用，向下计数没有问题
2. x
3. 在fs之后有一段是空窗期，
   1. 如果向下计数data_cnt自动置为4‘hF;
   2. 如果向上计数data_cnt自动置为4‘h1;
   3. 我怀疑是fd没有传出去
   4. 而且这个空窗期所有的灯应该都没有完全亮

这个简直太坑了，一定要记录一下，一会儿再试试

////////////////////////////////////////////////////////

新增模块，一共有32个led灯，可以同时兼听4个字节，方便调试
其xdc文件值得参考
该模块调试成功

////////////////////////////////////////////////////////

修改了key的文件，之前的key会出现连续按键的情况
如果这样的按键出现在串口发送过程中，在按键过程中会疯狂发数据
所以现在更改为必须按一次发送一次

现在串口发送成功，之后测试串口接收，再之后把fifo联系在一起
串口初步发送成功

////////////////////////////////////////////////////////
按键测试成功，按键具有防抖设置，在0.01s必须按键都被按下才被识别是按键一次
产生的flag可以延续1s，或者事件完成置低

////////////////////////////////////////////////////////
串口测试
完全失败，现在能够接收到最后一个字节，通过led显示完全正确
但是无法计数接收的数据长度
计划先测试一个key模块

////////////////////////////////////////////////////////
测试串口
新开一个新的方向，使用串口通信
复制例程，debug成功

////////////////////////////////////////////////////////
测试mac_rx_lite
现在接收数据可以完成，可以看到接收数据的长度
发送数据可以完成，但是会大量发送
01 00 00 01 00 00 01 00 01 00 01 00 （发送12个数据 55 AA 00 01 02 03 04 05 06 07 08 1C）
01 00 00 01 00 01 00 01 00 01 00 00 01 00 （发送14个数据 55 AA 00 01 02 03 04 05 06 07 08 1C 1D 1E）
表示发送数据的最后一位
在reset之后结束发送
////////////////////////////////////////////////////////